"""
Задание 1
Нужно реализовать класс Stack со следующими методами:
is_empty — проверка стека на пустоту. Метод возвращает True или False;
push — добавляет новый элемент на вершину стека. Метод ничего не возвращает;
pop — удаляет верхний элемент стека. Стек изменяется. Метод возвращает верхний элемент стека;
peek — возвращает верхний элемент стека, но не удаляет его. Стек не меняется;
size — возвращает количество элементов в стеке.

Задание 2
Используя стек из задания 1, решите задачу на проверку сбалансированности скобок.
Сбалансированность скобок означает, что каждый открывающий символ имеет соответствующий ему
закрывающий, и пары скобок правильно вложены друг в друга.
Пример сбалансированных последовательностей скобок:

(((([{}]))))
[([])((([[[]]])))]{()}
{{[()]}}
Несбалансированные последовательности:

}{}
{{[(])]}}
[[{())}]
Программа ожидает на вход строку со скобками. На выход сообщение: «Сбалансированно», если строка
корректная, и «Несбалансированно», если строка составлена неверно.
"""


class Stack:
    """
    Класс, реализующий структуру данных 'Стек' (LIFO — Last In, First Out).

    Методы:
        is_empty: Проверяет, пуст ли стек.
        push: Добавляет элемент на вершину стека.
        pop: Удаляет верхний элемент и возвращает его.
        peek: Возвращает верхний элемент стека без удаления.
        size: Возвращает количество элементов в стеке.
    """

    def __init__(self) -> None:
        """
        Инициализация стека с использованием пустого списка.
        """
        self.items = []

    def is_empty(self) -> bool:
        """
        Проверка стека на пустоту.

        Returns:
            bool: True, если стек пуст, иначе False.
        """
        return len(self.items) == 0

    def push(self, item: any) -> None:
        """
        Добавляет новый элемент на вершину стека.

        Args:
            item (any): Элемент, который нужно добавить в стек.
        """
        self.items.append(item)

    def pop(self) -> any:
        """
        Удаляет верхний элемент стека и возвращает его.

        Returns:
            any: Верхний элемент стека.
        """
        if not self.is_empty():
            return self.items.pop()
        else:
            raise IndexError("Попытка извлечь элемент из пустого стека")

    def peek(self) -> any:
        """
        Возвращает верхний элемент стека без его удаления.

        Returns:
            any: Верхний элемент стека.
        """
        if not self.is_empty():
            return self.items[-1]
        else:
            raise IndexError("Попытка заглянуть в пустой стек")

    def size(self) -> int:
        """
        Возвращает количество элементов в стеке.

        Returns:
            int: Количество элементов в стеке.
        """
        return len(self.items)


# Задание 2
def is_balanced(sequence: str) -> str:
    """
    Проверяет сбалансированность скобок в строке.

    Args:
        sequence (str): Строка, содержащая скобки для проверки.

    Returns:
        str: Сообщение "Сбалансированно", если скобки корректно сбалансированы,
        иначе "Несбалансированно".
    """
    stack = Stack()
    opening_brackets = "({["
    closing_brackets = ")}]"
    matching_brackets = {")": "(", "}": "{", "]": "["}

    for char in sequence:
        if char in opening_brackets:
            stack.push(char)
        elif char in closing_brackets:
            if stack.is_empty() or stack.pop() != matching_brackets[char]:
                return "Несбалансированно"

    return "Сбалансированно" if stack.is_empty() else "Несбалансированно"


if __name__ == '__main__':
    balanced_sequences = [
        "(((([{}]))))",
        "[([])((([[[]]])))]{()}",
        "{{[()]}}"
    ]
    unbalanced_sequences = [
        "}{",
        "{{[(])]}",
        "[[{())}]"
    ]

    for seq in balanced_sequences:
        print(f'{seq} -> {is_balanced(seq)}')  # Ожидается: Сбалансированно

    for seq in unbalanced_sequences:
        print(f'{seq} -> {is_balanced(seq)}')  # Ожидается: Несбалансированно
